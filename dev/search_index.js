var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Module","page":"API Reference","title":"Module","text":"","category":"section"},{"location":"api/#Result-Types","page":"API Reference","title":"Result Types","text":"","category":"section"},{"location":"api/#Detection-Algorithms","page":"API Reference","title":"Detection Algorithms","text":"","category":"section"},{"location":"api/#Continuous-Methods","page":"API Reference","title":"Continuous Methods","text":"","category":"section"},{"location":"api/#Discrete-Methods","page":"API Reference","title":"Discrete Methods","text":"","category":"section"},{"location":"api/#Multi-Pair-Methods","page":"API Reference","title":"Multi-Pair Methods","text":"","category":"section"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#CorePeriphery","page":"API Reference","title":"CorePeriphery","text":"CorePeriphery\n\nA Julia module implementing various core-periphery detection algorithms for network analysis.\n\nCore-periphery structure is a mesoscale pattern in networks where nodes are divided into a densely interconnected core and a sparsely connected periphery.\n\nAlgorithms Implemented\n\nBorgatti-Everett continuous model (2000)\nBorgatti-Everett discrete model (2000)\nLip's fast discrete algorithm (2011)\nRombach's generalized model (2017)\nSpectral method (Cucuringu et al., 2016)\nRandom walker profiling (Rossa et al., 2013)\nMINRES/SVD for asymmetric networks (Boyd et al., 2010)\nMultiple core-periphery pairs (Kojaku & Masuda, 2017)\nSurprise-based detection (Jeude et al., 2019)\nLabel-switching algorithm (Yanchenko & Sengupta, 2025)\n\nReferences\n\nBorgatti, S.P., Everett, M.G. (2000). Models of core/periphery structures.\nLip, S.Z.W. (2011). A Fast Algorithm for the Discrete Core/Periphery Bipartitioning Problem.\nRombach, M.P., et al. (2017). Core-Periphery Structure in Networks (Revisited).\nCucuringu, M., et al. (2016). Detection of core-periphery structure using spectral methods.\nRossa, F.D., et al. (2013). Profiling core-periphery network structure by random walkers.\nBoyd, J.P., et al. (2010). Computing core/periphery structures and permutation tests.\nKojaku, S., Masuda, N. (2017). Finding multiple core-periphery pairs in networks.\nJeude, J., et al. (2019). Detecting Core-Periphery Structures by Surprise.\nYanchenko, K., Sengupta, S. (2025). A fast label-switching algorithm for core-periphery detection.\n\n\n\n\n\n","category":"module"},{"location":"api/#CorePeriphery.CPResult","page":"API Reference","title":"CorePeriphery.CPResult","text":"CPResult\n\nResult structure for core-periphery detection algorithms.\n\nFields\n\ncoreness::Vector{Float64}: Coreness score for each node (higher = more core-like)\ncore_nodes::Vector{Int}: Indices of nodes classified as core\nperiphery_nodes::Vector{Int}: Indices of nodes classified as periphery\nquality::Float64: Quality score of the partition (algorithm-specific)\nalgorithm::String: Name of the algorithm used\n\n\n\n\n\n","category":"type"},{"location":"api/#CorePeriphery.CPMultiResult","page":"API Reference","title":"CorePeriphery.CPMultiResult","text":"CPMultiResult\n\nResult structure for multiple core-periphery pairs detection.\n\nFields\n\npair_labels::Vector{Int}: Pair assignment for each node (1, 2, ..., K)\ncoreness::Vector{Float64}: Binary coreness within each pair\nn_pairs::Int: Number of detected core-periphery pairs\nquality::Float64: Quality score (Q^cp)\nalgorithm::String: Name of the algorithm used\n\n\n\n\n\n","category":"type"},{"location":"api/#CorePeriphery.borgatti_everett_continuous","page":"API Reference","title":"CorePeriphery.borgatti_everett_continuous","text":"borgatti_everett_continuous(A; max_iter=1000, tol=1e-6, init=nothing)\n\nBorgatti-Everett continuous core-periphery model.\n\nFinds coreness vector c that maximizes correlation with ideal pattern Δ[i,j] = c[i]*c[j].\n\nArguments\n\nA: Adjacency matrix (n x n)\nmax_iter: Maximum iterations\ntol: Convergence tolerance\ninit: Initial coreness vector (optional)\n\nReturns\n\nCPResult with continuous coreness scores\n\nReference\n\nBorgatti, S.P., Everett, M.G. (2000). Models of core/periphery structures.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.rombach_continuous","page":"API Reference","title":"CorePeriphery.rombach_continuous","text":"rombach_continuous(A; alpha=0.5, beta=0.5, max_iter=1000, tol=1e-6, n_runs=10)\n\nRombach's generalized continuous core-periphery model.\n\nUses transition function controlled by α and β parameters.\n\nArguments\n\nA: Adjacency matrix\nalpha: Controls sharpness of core-periphery boundary\nbeta: Controls size of core\nmax_iter: Maximum iterations per run\ntol: Convergence tolerance\nn_runs: Number of random restarts\n\nReturns\n\nCPResult with continuous coreness scores\n\nReference\n\nRombach, M.P., et al. (2017). Core-Periphery Structure in Networks (Revisited).\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.spectral_method","page":"API Reference","title":"CorePeriphery.spectral_method","text":"spectral_method(A)\n\nSpectral method for core-periphery detection.\n\nUses eigenvector corresponding to largest eigenvalue of adjacency matrix.\n\nArguments\n\nA: Adjacency matrix\n\nReturns\n\nCPResult with spectral-based coreness scores\n\nReference\n\nCucuringu, M., et al. (2016). Detection of core-periphery structure using spectral methods.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.random_walker_profiling","page":"API Reference","title":"CorePeriphery.random_walker_profiling","text":"random_walker_profiling(A; n_walks=1000, walk_length=10)\n\nRandom walker profiling for core-periphery detection.\n\nNodes visited more frequently by random walks are more core-like.\n\nArguments\n\nA: Adjacency matrix\nn_walks: Number of random walks\nwalk_length: Length of each walk\n\nReturns\n\nCPResult with visit-frequency-based coreness\n\nReference\n\nRossa, F.D., et al. (2013). Profiling core-periphery network structure by random walkers.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.minres_svd","page":"API Reference","title":"CorePeriphery.minres_svd","text":"minres_svd(A; max_iter=1000, tol=1e-6)\n\nMINRES/SVD algorithm for core-periphery detection in asymmetric networks.\n\nMinimizes residual f = Σᵢ Σⱼ≠ᵢ (Aᵢⱼ - uᵢvⱼ)² to find in-coreness (v) and out-coreness (u).\n\nArguments\n\nA: Adjacency matrix (can be asymmetric)\nmax_iter: Maximum iterations\ntol: Convergence tolerance\n\nReturns\n\nCPResult with coreness scores (average of in/out for asymmetric)\nFor symmetric matrices, in-coreness equals out-coreness\n\nReference\n\nBoyd, J.P., et al. (2010). Computing core/periphery structures and permutation tests for social relations data.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.borgatti_everett_discrete","page":"API Reference","title":"CorePeriphery.borgatti_everett_discrete","text":"borgatti_everett_discrete(A; max_iter=1000, init=nothing)\n\nBorgatti-Everett discrete core-periphery model.\n\nFinds binary partition maximizing correlation with ideal discrete pattern.\n\nArguments\n\nA: Adjacency matrix\nmax_iter: Maximum iterations for optimization\ninit: Initial binary assignment (optional)\n\nReturns\n\nCPResult with binary coreness (0 or 1)\n\nReference\n\nBorgatti, S.P., Everett, M.G. (2000). Models of core/periphery structures.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.lip_discrete","page":"API Reference","title":"CorePeriphery.lip_discrete","text":"lip_discrete(A; max_iter=1000)\n\nLip's fast algorithm for discrete core-periphery bipartitioning.\n\nUses efficient swap-based optimization with O(n) updates per iteration.\n\nArguments\n\nA: Adjacency matrix\nmax_iter: Maximum iterations\n\nReturns\n\nCPResult with binary partition\n\nReference\n\nLip, S.Z.W. (2011). A Fast Algorithm for the Discrete Core/Periphery Bipartitioning Problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.surprise_cp","page":"API Reference","title":"CorePeriphery.surprise_cp","text":"surprise_cp(A; max_iter=100)\n\nSurprise-based core-periphery detection.\n\nUses multinomial hypergeometric distribution to compute surprise of CP structure.\n\nArguments\n\nA: Adjacency matrix\nmax_iter: Maximum optimization iterations\n\nReturns\n\nCPResult with binary coreness\n\nReference\n\nJeude, J., et al. (2019). Detecting Core-Periphery Structures by Surprise.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.label_switching_cp","page":"API Reference","title":"CorePeriphery.label_switching_cp","text":"label_switching_cp(A; max_iter=100)\n\nFast label-switching algorithm for core-periphery detection.\n\nUses greedy optimization with efficient O(n) updates per iteration.\n\nArguments\n\nA: Adjacency matrix\nmax_iter: Maximum iterations\n\nReturns\n\nCPResult with binary coreness\n\nReference\n\nYanchenko, K., Sengupta, S. (2025). A fast label-switching algorithm for core-periphery detection.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.multiple_cp_pairs","page":"API Reference","title":"CorePeriphery.multiple_cp_pairs","text":"multiple_cp_pairs(A; max_pairs=10, min_pair_size=2, max_iter=100)\n\nDetect multiple non-overlapping core-periphery pairs.\n\nUses quality function Q^cp and label switching optimization.\n\nArguments\n\nA: Adjacency matrix\nmax_pairs: Maximum number of CP pairs to detect\nmin_pair_size: Minimum nodes per pair\nmax_iter: Maximum iterations for optimization\n\nReturns\n\nCPMultiResult with pair assignments and coreness\n\nReference\n\nKojaku, S., Masuda, N. (2017). Finding multiple core-periphery pairs in networks.\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.adjacency_to_matrix","page":"API Reference","title":"CorePeriphery.adjacency_to_matrix","text":"adjacency_to_matrix(edges, n)\n\nConvert edge list to adjacency matrix.\n\nArguments\n\nedges: Vector of tuples (i, j) or (i, j, weight)\nn: Number of nodes\n\nReturns\n\nSymmetric adjacency matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.ideal_cp_matrix","page":"API Reference","title":"CorePeriphery.ideal_cp_matrix","text":"ideal_cp_matrix(c)\n\nGenerate the ideal core-periphery pattern matrix for a given coreness vector.\n\nFor continuous model: Δ[i,j] = c[i] * c[j] For discrete model: Δ[i,j] = max(c[i], c[j])\n\nArguments\n\nc::Vector{Float64}: Coreness vector (values in [0,1])\ndiscrete::Bool: If true, use discrete ideal pattern\n\nReturns\n\nIdeal core-periphery matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.core_quality","page":"API Reference","title":"CorePeriphery.core_quality","text":"core_quality(A, c; discrete=false)\n\nCompute quality (correlation) between adjacency matrix and ideal core-periphery pattern.\n\nArguments\n\nA: Adjacency matrix\nc: Coreness vector\ndiscrete: Use discrete ideal pattern\n\nReturns\n\nPearson correlation coefficient\n\n\n\n\n\n","category":"function"},{"location":"api/#CorePeriphery.coreness_scores","page":"API Reference","title":"CorePeriphery.coreness_scores","text":"coreness_scores(result::CPResult)\n\nGet coreness scores from a CPResult.\n\nReturns\n\nVector of coreness scores (higher = more core-like)\n\n\n\n\n\n","category":"function"},{"location":"#CorePeriphery.jl","page":"Home","title":"CorePeriphery.jl","text":"A Julia package for detecting core-periphery structure in networks.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Core-periphery structure is a fundamental mesoscale pattern in complex networks where nodes are partitioned into two groups:\n\nCore: A densely interconnected group of central nodes\nPeriphery: Sparsely connected nodes that attach to the core but not to each other\n\nThis pattern appears in many real-world networks including social networks, economic systems, biological networks, and transportation infrastructure. CorePeriphery.jl provides multiple algorithms for detecting and quantifying this structure.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"10 detection algorithms covering discrete, continuous, and multi-pair methods\nWeighted network support for analyzing networks with edge weights\nDirected network support via the MINRES/SVD algorithm\nPure Julia implementation with no dependencies beyond the standard library\nConsistent API with unified result structures across all algorithms","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/simoneSantoni/CorePeriphery.jl\")\n\nOr for development:\n\nusing Pkg\nPkg.develop(path=\"/path/to/CorePeriphery.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using CorePeriphery\n\n# Create a network from an edge list\nedges = [\n    (1, 2), (1, 3), (1, 4), (1, 5),  # Node 1 connected to many\n    (2, 3), (2, 4), (2, 5),           # Node 2 also well-connected\n    (3, 4), (3, 5),\n    (6, 1), (7, 2)                    # Peripheral nodes\n]\nA = adjacency_to_matrix(edges, 7)\n\n# Run a detection algorithm\nresult = borgatti_everett_continuous(A)\n\n# Access results\nprintln(\"Coreness scores: \", result.coreness)\nprintln(\"Core nodes: \", result.core_nodes)\nprintln(\"Periphery nodes: \", result.periphery_nodes)\nprintln(\"Quality: \", result.quality)","category":"section"},{"location":"#Choosing-an-Algorithm","page":"Home","title":"Choosing an Algorithm","text":"Use Case Recommended Algorithm\nFast binary classification lip_discrete or label_switching_cp\nContinuous coreness scores borgatti_everett_continuous or spectral_method\nDirected networks minres_svd\nMultiple CP structures multiple_cp_pairs\nTunable core boundary rombach_continuous\nStatistical significance surprise_cp","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Pages = [\"tutorial.md\", \"algorithms.md\", \"api.md\"]\nDepth = 2","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Borgatti, S.P., Everett, M.G. (2000). Models of core/periphery structures. Social Networks, 21(4), 375-395.\nLip, S.Z.W. (2011). A Fast Algorithm for the Discrete Core/Periphery Bipartitioning Problem. arXiv:1102.5511.\nRombach, M.P., Porter, M.A., Fowler, J.H., Mucha, P.J. (2017). Core-Periphery Structure in Networks (Revisited). SIAM Review, 59(3), 619-646.\nCucuringu, M., et al. (2016). Detection of core-periphery structure in networks using spectral methods and geodesic paths. European Journal of Applied Mathematics, 27(6), 846-887.\nDella Rossa, F., Dercole, F., Piccardi, C. (2013). Profiling core-periphery network structure by random walkers. Scientific Reports, 3, 1467.\nBoyd, J.P., et al. (2010). Computing continuous core/periphery structures for social relations data with MINRES/SVD. Social Networks, 32(2), 125-137.\nKojaku, S., Masuda, N. (2017). Finding multiple core-periphery pairs in networks. Physical Review E, 96(5), 052313.\nJeude, J., et al. (2019). Detecting Core-Periphery Structures by Surprise. EPL, 125(6), 68001.\nYanchenko, K., Sengupta, S. (2025). A fast label-switching algorithm for core-periphery detection in networks. arXiv preprint.","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial walks through common use cases for CorePeriphery.jl.","category":"section"},{"location":"tutorial/#Creating-Networks","page":"Tutorial","title":"Creating Networks","text":"","category":"section"},{"location":"tutorial/#From-Edge-Lists","page":"Tutorial","title":"From Edge Lists","text":"The most common way to create a network is from an edge list:\n\nusing CorePeriphery\n\n# Unweighted edges as (source, target) tuples\nedges = [\n    (1, 2), (1, 3), (1, 4),\n    (2, 3), (2, 4),\n    (3, 4),\n    (5, 1), (6, 2)  # Peripheral nodes\n]\nA = adjacency_to_matrix(edges, 6)","category":"section"},{"location":"tutorial/#Weighted-Networks","page":"Tutorial","title":"Weighted Networks","text":"For weighted networks, include weights as the third element:\n\nweighted_edges = [\n    (1, 2, 5.0),  # Strong connection\n    (1, 3, 3.0),\n    (2, 3, 4.0),\n    (4, 1, 1.0),  # Weak peripheral connection\n]\nA = adjacency_to_matrix(weighted_edges, 4)","category":"section"},{"location":"tutorial/#From-Existing-Matrices","page":"Tutorial","title":"From Existing Matrices","text":"If you already have an adjacency matrix, you can use it directly:\n\nusing LinearAlgebra\n\n# Create a 6x6 adjacency matrix\nA = zeros(6, 6)\nA[1, 2] = A[2, 1] = 1.0\nA[1, 3] = A[3, 1] = 1.0\n# ... etc","category":"section"},{"location":"tutorial/#Basic-Core-Periphery-Detection","page":"Tutorial","title":"Basic Core-Periphery Detection","text":"","category":"section"},{"location":"tutorial/#Running-an-Algorithm","page":"Tutorial","title":"Running an Algorithm","text":"All algorithms follow the same pattern:\n\nresult = borgatti_everett_continuous(A)","category":"section"},{"location":"tutorial/#Understanding-Results","page":"Tutorial","title":"Understanding Results","text":"The result is a CPResult struct with several fields:\n\n# Coreness scores (0 to 1, higher = more core-like)\nprintln(result.coreness)\n\n# Nodes classified as core\nprintln(result.core_nodes)\n\n# Nodes classified as periphery\nprintln(result.periphery_nodes)\n\n# Quality score (correlation with ideal pattern)\nprintln(result.quality)\n\n# Algorithm name\nprintln(result.algorithm)","category":"section"},{"location":"tutorial/#Visualizing-Results","page":"Tutorial","title":"Visualizing Results","text":"# Sort nodes by coreness\nsorted_idx = sortperm(result.coreness, rev=true)\n\nprintln(\"Node ranking by coreness:\")\nfor (rank, idx) in enumerate(sorted_idx)\n    score = round(result.coreness[idx], digits=3)\n    label = idx in result.core_nodes ? \"CORE\" : \"PERIPHERY\"\n    println(\"  $rank. Node $idx: $score ($label)\")\nend","category":"section"},{"location":"tutorial/#Comparing-Algorithms","page":"Tutorial","title":"Comparing Algorithms","text":"Different algorithms may identify different core-periphery structures:\n\n# Run multiple algorithms\nresults = [\n    borgatti_everett_continuous(A),\n    borgatti_everett_discrete(A),\n    lip_discrete(A),\n    spectral_method(A),\n    random_walker_profiling(A),\n    minres_svd(A),\n    surprise_cp(A),\n    label_switching_cp(A)\n]\n\n# Compare quality scores\nprintln(\"Algorithm Comparison:\")\nprintln(\"-\" ^ 50)\nfor r in results\n    q = round(r.quality, digits=4)\n    n_core = length(r.core_nodes)\n    println(\"$(rpad(r.algorithm, 30)) Quality: $q  Core: $n_core\")\nend","category":"section"},{"location":"tutorial/#Measuring-Agreement","page":"Tutorial","title":"Measuring Agreement","text":"To compare which nodes different algorithms classify as core:\n\nusing Statistics\n\nfunction jaccard_similarity(set1, set2)\n    intersection = length(intersect(Set(set1), Set(set2)))\n    union = length(union(Set(set1), Set(set2)))\n    return union > 0 ? intersection / union : 1.0\nend\n\n# Compare core node sets\nr1 = borgatti_everett_continuous(A)\nr2 = spectral_method(A)\n\nsimilarity = jaccard_similarity(r1.core_nodes, r2.core_nodes)\nprintln(\"Jaccard similarity of core sets: $similarity\")","category":"section"},{"location":"tutorial/#Working-with-Specific-Algorithms","page":"Tutorial","title":"Working with Specific Algorithms","text":"","category":"section"},{"location":"tutorial/#Tuning-Rombach's-Model","page":"Tutorial","title":"Tuning Rombach's Model","text":"The Rombach model has parameters to control the core-periphery structure:\n\n# Sharp boundary, small core\nresult1 = rombach_continuous(A; alpha=0.9, beta=0.3)\n\n# Soft boundary, large core\nresult2 = rombach_continuous(A; alpha=0.1, beta=0.7)\n\n# Grid search over parameters\nbest_quality = -Inf\nbest_params = nothing\n\nfor alpha in 0.1:0.2:0.9\n    for beta in 0.1:0.2:0.9\n        r = rombach_continuous(A; alpha=alpha, beta=beta, n_runs=3)\n        if r.quality > best_quality\n            best_quality = r.quality\n            best_params = (alpha=alpha, beta=beta)\n        end\n    end\nend\n\nprintln(\"Best parameters: α=$(best_params.alpha), β=$(best_params.beta)\")","category":"section"},{"location":"tutorial/#Random-Walker-Parameters","page":"Tutorial","title":"Random Walker Parameters","text":"Adjust walk parameters based on network size:\n\nn = size(A, 1)\n\n# For small networks (< 100 nodes)\nresult_small = random_walker_profiling(A; n_walks=1000, walk_length=10)\n\n# For larger networks\nresult_large = random_walker_profiling(A; n_walks=n*100, walk_length=20)","category":"section"},{"location":"tutorial/#Directed-Networks-with-MINRES/SVD","page":"Tutorial","title":"Directed Networks with MINRES/SVD","text":"For directed networks, use minres_svd:\n\n# Create a directed network (asymmetric matrix)\nA_directed = zeros(5, 5)\nA_directed[1, 2] = 1.0  # 1 → 2\nA_directed[1, 3] = 1.0  # 1 → 3\nA_directed[2, 3] = 1.0  # 2 → 3\nA_directed[4, 1] = 1.0  # 4 → 1\nA_directed[5, 2] = 1.0  # 5 → 2\n\nresult = minres_svd(A_directed)\n\nNote: The result averages in-coreness and out-coreness. For separate values, you would need to access the algorithm internals.","category":"section"},{"location":"tutorial/#Multiple-Core-Periphery-Pairs","page":"Tutorial","title":"Multiple Core-Periphery Pairs","text":"Some networks contain multiple distinct CP structures:\n\n# Create a network with two communities, each with CP structure\nA = zeros(12, 12)\n\n# Community 1 (nodes 1-6): nodes 1-2 are core\nfor i in 1:2, j in 1:6\n    if i != j\n        A[i, j] = A[j, i] = 1.0\n    end\nend\n\n# Community 2 (nodes 7-12): nodes 7-8 are core\nfor i in 7:8, j in 7:12\n    if i != j\n        A[i, j] = A[j, i] = 1.0\n    end\nend\n\n# Detect multiple pairs\nresult = multiple_cp_pairs(A)\n\nprintln(\"Number of CP pairs detected: $(result.n_pairs)\")\nprintln(\"Pair labels: $(result.pair_labels)\")\nprintln(\"Within-pair coreness: $(result.coreness)\")","category":"section"},{"location":"tutorial/#Quality-Assessment","page":"Tutorial","title":"Quality Assessment","text":"","category":"section"},{"location":"tutorial/#Computing-Quality-Manually","page":"Tutorial","title":"Computing Quality Manually","text":"# Get a coreness vector (from algorithm or custom)\nc = result.coreness\n\n# Compute quality with continuous ideal pattern\nq_cont = core_quality(A, c; discrete=false)\n\n# Compute quality with discrete ideal pattern\nc_binary = Float64.(c .>= median(c))\nq_disc = core_quality(A, c_binary; discrete=true)\n\nprintln(\"Continuous quality: $q_cont\")\nprintln(\"Discrete quality: $q_disc\")","category":"section"},{"location":"tutorial/#Ideal-Pattern-Visualization","page":"Tutorial","title":"Ideal Pattern Visualization","text":"# Generate the ideal CP matrix\nc = [1.0, 0.9, 0.8, 0.3, 0.2, 0.1]  # Example coreness\nideal_cont = ideal_cp_matrix(c; discrete=false)\nideal_disc = ideal_cp_matrix(c; discrete=true)\n\n# Compare with actual adjacency\nprintln(\"Continuous ideal pattern:\")\ndisplay(round.(ideal_cont, digits=2))\n\nprintln(\"\\nDiscrete ideal pattern:\")\ndisplay(round.(ideal_disc, digits=2))","category":"section"},{"location":"tutorial/#Synthetic-Network-Generation","page":"Tutorial","title":"Synthetic Network Generation","text":"For testing and validation, create networks with known CP structure:\n\nusing Random\n\nfunction generate_cp_network(n_core, n_periphery;\n                             p_cc=0.8, p_cp=0.4, p_pp=0.05, seed=nothing)\n    if seed !== nothing\n        Random.seed!(seed)\n    end\n\n    n = n_core + n_periphery\n    A = zeros(Float64, n, n)\n\n    for i in 1:n, j in (i+1):n\n        # Determine probability based on node types\n        if i <= n_core && j <= n_core\n            p = p_cc  # Core-core\n        elseif i <= n_core || j <= n_core\n            p = p_cp  # Core-periphery\n        else\n            p = p_pp  # Periphery-periphery\n        end\n\n        if rand() < p\n            A[i, j] = A[j, i] = 1.0\n        end\n    end\n\n    return A\nend\n\n# Generate and test\nA = generate_cp_network(5, 15; seed=42)\nresult = borgatti_everett_continuous(A)\n\n# True labels (first 5 are core)\ntrue_core = Set(1:5)\ndetected_core = Set(result.core_nodes)\n\nprecision = length(intersect(true_core, detected_core)) / length(detected_core)\nrecall = length(intersect(true_core, detected_core)) / length(true_core)\n\nprintln(\"Precision: $(round(precision, digits=3))\")\nprintln(\"Recall: $(round(recall, digits=3))\")","category":"section"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"CorePeriphery.jl implements 10 algorithms for detecting core-periphery structure. This page provides detailed descriptions of each algorithm, their theoretical foundations, and guidance on when to use them.","category":"section"},{"location":"algorithms/#Algorithm-Categories","page":"Algorithms","title":"Algorithm Categories","text":"The algorithms can be grouped into three categories:\n\nContinuous methods: Assign each node a coreness score in [0, 1]\nDiscrete methods: Classify nodes as either core (1) or periphery (0)\nMulti-pair methods: Detect multiple non-overlapping core-periphery pairs","category":"section"},{"location":"algorithms/#Borgatti-Everett-Continuous-Model","page":"Algorithms","title":"Borgatti-Everett Continuous Model","text":"result = borgatti_everett_continuous(A; max_iter=1000, tol=1e-6, init=nothing)\n\nThe classic continuous core-periphery model introduced by Borgatti and Everett (2000). It finds a coreness vector c that maximizes the correlation between the adjacency matrix A and an ideal core-periphery pattern:\n\nDelta_ij = c_i times c_j\n\nAlgorithm: Coordinate ascent optimization. Each node's coreness is updated iteratively while holding others fixed.\n\nParameters:\n\nmax_iter: Maximum iterations (default: 1000)\ntol: Convergence tolerance (default: 1e-6)\ninit: Initial coreness vector (default: degree centrality)\n\nWhen to use: When you need continuous coreness scores and want a well-established baseline method.","category":"section"},{"location":"algorithms/#Borgatti-Everett-Discrete-Model","page":"Algorithms","title":"Borgatti-Everett Discrete Model","text":"result = borgatti_everett_discrete(A; max_iter=1000, init=nothing)\n\nThe discrete version of the Borgatti-Everett model. Finds a binary partition maximizing correlation with the ideal discrete pattern:\n\nDelta_ij = max(c_i c_j)\n\nwhere c_i in 0 1.\n\nAlgorithm: Greedy optimization that iteratively flips node labels to improve quality.\n\nParameters:\n\nmax_iter: Maximum iterations (default: 1000)\ninit: Initial binary assignment (default: degree-based)\n\nWhen to use: When you need a binary classification and want to maximize correlation with the ideal discrete pattern.","category":"section"},{"location":"algorithms/#Lip's-Fast-Discrete-Algorithm","page":"Algorithms","title":"Lip's Fast Discrete Algorithm","text":"result = lip_discrete(A; max_iter=1000)\n\nAn efficient algorithm for discrete core-periphery detection introduced by Lip (2011). Optimizes a simpler objective: maximizing the number of edges involving at least one core node.\n\nAlgorithm: Swap-based optimization with O(n) updates per iteration. Maintains running statistics for efficient delta computations.\n\nParameters:\n\nmax_iter: Maximum iterations (default: 1000)\n\nWhen to use: When you need fast discrete classification for large networks. Often faster than Borgatti-Everett discrete while achieving similar results.","category":"section"},{"location":"algorithms/#Rombach's-Generalized-Model","page":"Algorithms","title":"Rombach's Generalized Model","text":"result = rombach_continuous(A; alpha=0.5, beta=0.5, max_iter=1000, tol=1e-6, n_runs=10)\n\nA generalized continuous model by Rombach et al. (2017) with parameters controlling the core-periphery structure:\n\nalpha: Controls the sharpness of the core-periphery boundary\nbeta: Controls the relative size of the core\n\nThe ideal pattern uses a transition function g(c_i alpha beta) to compute Delta_ij = g(c_i) times g(c_j).\n\nAlgorithm: Grid search optimization with random restarts.\n\nParameters:\n\nalpha: Boundary sharpness, 0 to 1 (default: 0.5)\nbeta: Core size parameter, 0 to 1 (default: 0.5)\nn_runs: Number of random restarts (default: 10)\n\nWhen to use: When you want to tune the expected core-periphery structure or explore how results change with different boundary definitions.","category":"section"},{"location":"algorithms/#Spectral-Method","page":"Algorithms","title":"Spectral Method","text":"result = spectral_method(A)\n\nUses the eigenvector corresponding to the largest eigenvalue of the adjacency matrix to determine coreness (Cucuringu et al., 2016).\n\nAlgorithm: Eigendecomposition of the adjacency matrix. The leading eigenvector components (absolute values, normalized) give coreness scores.\n\nParameters: None\n\nWhen to use: Fast method for continuous coreness scores. Works well when the core-periphery structure aligns with the network's spectral properties. No iterative optimization needed.","category":"section"},{"location":"algorithms/#Random-Walker-Profiling","page":"Algorithms","title":"Random Walker Profiling","text":"result = random_walker_profiling(A; n_walks=1000, walk_length=10)\n\nBased on the insight that random walkers spend more time at core nodes (Della Rossa et al., 2013). Coreness is determined by visit frequency.\n\nAlgorithm: Simulate random walks starting from random nodes. Count visits to each node and normalize to get coreness scores.\n\nParameters:\n\nn_walks: Number of random walks (default: 1000)\nwalk_length: Steps per walk (default: 10)\n\nWhen to use: When you want a dynamics-based definition of coreness. Useful for understanding network flow and accessibility.","category":"section"},{"location":"algorithms/#MINRES/SVD-Method","page":"Algorithms","title":"MINRES/SVD Method","text":"result = minres_svd(A; max_iter=1000, tol=1e-6)\n\nMinimizes the residual between the adjacency matrix and an outer product model (Boyd et al., 2010):\n\nmin_uv sum_i neq j (A_ij - u_i v_j)^2\n\nThis yields separate in-coreness (v) and out-coreness (u) vectors, which are averaged for the final coreness scores.\n\nAlgorithm: Alternating least squares optimization.\n\nParameters:\n\nmax_iter: Maximum iterations (default: 1000)\ntol: Convergence tolerance (default: 1e-6)\n\nWhen to use: The only algorithm that handles directed (asymmetric) networks. For undirected networks, in-coreness equals out-coreness.","category":"section"},{"location":"algorithms/#Multiple-Core-Periphery-Pairs","page":"Algorithms","title":"Multiple Core-Periphery Pairs","text":"result = multiple_cp_pairs(A; max_pairs=10, min_pair_size=2, max_iter=100)\n\nDetects multiple non-overlapping core-periphery pairs using the Q^cp quality function (Kojaku & Masuda, 2017).\n\nAlgorithm:\n\nInitialize each node as its own pair\nGreedily merge pairs to maximize Q^cp\nOptimize core/periphery assignment within each pair\n\nReturns a CPMultiResult with pair labels and within-pair coreness.\n\nParameters:\n\nmax_pairs: Maximum number of pairs (default: 10)\nmin_pair_size: Minimum nodes per pair (default: 2)\nmax_iter: Optimization iterations (default: 100)\n\nWhen to use: When you expect the network to contain multiple distinct core-periphery structures rather than a single global one.","category":"section"},{"location":"algorithms/#Surprise-Based-Detection","page":"Algorithms","title":"Surprise-Based Detection","text":"result = surprise_cp(A; max_iter=100)\n\nUses statistical surprise to find partitions that are unlikely under a random null model (Jeude et al., 2019). Surprise is higher when:\n\nCore-core and core-periphery edges are more than expected\nPeriphery-periphery edges are fewer than expected\n\nAlgorithm: Greedy optimization of the surprise score.\n\nParameters:\n\nmax_iter: Maximum iterations (default: 100)\n\nWhen to use: When you want a statistically-motivated definition of core-periphery structure.","category":"section"},{"location":"algorithms/#Label-Switching-Algorithm","page":"Algorithms","title":"Label Switching Algorithm","text":"result = label_switching_cp(A; max_iter=100)\n\nA fast greedy algorithm with efficient O(n) updates per iteration (Yanchenko & Sengupta, 2025). Optimizes the sum M = sum_ij A_ij Delta_ij with the discrete ideal pattern.\n\nAlgorithm:\n\nInitialize based on node degrees\nProcess nodes in random order\nFlip labels that improve the objective\nMaintain running neighbor statistics for O(1) delta computations\n\nParameters:\n\nmax_iter: Maximum iterations (default: 100)\n\nWhen to use: Fast discrete classification, especially for large networks. Similar to Lip's algorithm but with different optimization strategy.","category":"section"},{"location":"algorithms/#Comparison-Summary","page":"Algorithms","title":"Comparison Summary","text":"Algorithm Type Speed Directed Key Feature\nborgatti_everett_continuous Continuous Medium No Classic baseline\nborgatti_everett_discrete Discrete Medium No Optimal discrete correlation\nlip_discrete Discrete Fast No Efficient swap optimization\nrombach_continuous Continuous Slow No Tunable parameters\nspectral_method Continuous Fast No No iteration needed\nrandom_walker_profiling Continuous Medium No Dynamics-based\nminres_svd Continuous Medium Yes Handles asymmetric networks\nmultiple_cp_pairs Multi-pair Medium No Multiple structures\nsurprise_cp Discrete Medium No Statistical foundation\nlabel_switching_cp Discrete Fast No Efficient label updates","category":"section"}]
}
